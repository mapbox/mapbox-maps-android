// This file is generated.

package com.mapbox.maps.extension.compose.style.lights.generated

import android.os.Parcelable
import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.Stable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.Saver
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import com.mapbox.bindgen.Value
import com.mapbox.maps.MapboxExperimental
import com.mapbox.maps.MapboxMap
import com.mapbox.maps.MapboxStyleManager
import com.mapbox.maps.extension.compose.style.BooleanValue
import com.mapbox.maps.extension.compose.style.ColorValue
import com.mapbox.maps.extension.compose.style.DoubleListValue
import com.mapbox.maps.extension.compose.style.DoubleValue
import com.mapbox.maps.extension.compose.style.HoldsValue
import com.mapbox.maps.extension.compose.style.IdGenerator.generateRandomLightId
import com.mapbox.maps.extension.compose.style.StringValue
import com.mapbox.maps.extension.compose.style.Transition
import com.mapbox.maps.extension.compose.style.internal.ValueParceler
import com.mapbox.maps.logD
import com.mapbox.maps.logW
import kotlinx.parcelize.Parcelize
import kotlinx.parcelize.TypeParceler
import java.util.Objects

/**
 * Create and [rememberSaveable] a [DirectionalLightState] using [Saver].
 * [init] will be called when the [DirectionalLightState] is first created to configure its
 * initial state.
 *
 * @param key An optional key to be used as a key for the saved value. If not provided we use the
 * automatically generated by the Compose runtime which is unique for the every exact code location
 * in the composition tree.
 * @param init A function initialise this [DirectionalLightState].
 */
@Composable
public inline fun rememberDirectionalLightState(
  id: String = remember {
    generateRandomLightId("directional")
  },
  key: String? = null,
  crossinline init: DirectionalLightState.() -> Unit = {}
): DirectionalLightState = rememberSaveable(key = key, saver = DirectionalLightState.Saver) {
  DirectionalLightState(id).apply(init)
}

/**
 * A light that has a direction and is located at infinite distance, so its rays are parallel. It simulates the sun light and can cast shadows.
 *
 * @see [The online documentation](https://docs.mapbox.com/style-spec/reference/light)
 */
@Stable
public class DirectionalLightState internal constructor(
  /**
   * The id of the [DirectionalLightState].
   */
  public val id: String,
  initialCastShadows: BooleanValue = BooleanValue.INITIAL,
  initialColor: ColorValue = ColorValue.INITIAL,
  initialColorTransition: Transition = Transition.INITIAL,
  initialColorUseTheme: StringValue = StringValue.INITIAL,
  initialDirection: DoubleListValue = DoubleListValue.INITIAL,
  initialDirectionTransition: Transition = Transition.INITIAL,
  initialIntensity: DoubleValue = DoubleValue.INITIAL,
  initialIntensityTransition: Transition = Transition.INITIAL,
  initialShadowIntensity: DoubleValue = DoubleValue.INITIAL,
  initialShadowIntensityTransition: Transition = Transition.INITIAL,
) {
  public constructor(id: String = generateRandomLightId("directional")) : this(
    id = id,
    initialCastShadows = BooleanValue.INITIAL,
    initialColor = ColorValue.INITIAL,
    initialColorTransition = Transition.INITIAL,
    initialColorUseTheme = StringValue.INITIAL,
    initialDirection = DoubleListValue.INITIAL,
    initialDirectionTransition = Transition.INITIAL,
    initialIntensity = DoubleValue.INITIAL,
    initialIntensityTransition = Transition.INITIAL,
    initialShadowIntensity = DoubleValue.INITIAL,
    initialShadowIntensityTransition = Transition.INITIAL,
  )

  private val castShadowsState: MutableState<BooleanValue> = mutableStateOf(initialCastShadows)
  private val colorState: MutableState<ColorValue> = mutableStateOf(initialColor)
  private val colorTransitionState: MutableState<Transition> = mutableStateOf(initialColorTransition)
  private val colorUseThemeState: MutableState<StringValue> = mutableStateOf(initialColorUseTheme)
  private val directionState: MutableState<DoubleListValue> = mutableStateOf(initialDirection)
  private val directionTransitionState: MutableState<Transition> = mutableStateOf(initialDirectionTransition)
  private val intensityState: MutableState<DoubleValue> = mutableStateOf(initialIntensity)
  private val intensityTransitionState: MutableState<Transition> = mutableStateOf(initialIntensityTransition)
  private val shadowIntensityState: MutableState<DoubleValue> = mutableStateOf(initialShadowIntensity)
  private val shadowIntensityTransitionState: MutableState<Transition> = mutableStateOf(initialShadowIntensityTransition)

  /**
   * Enable/Disable shadow casting for this light
   * Default value: false.
   */
  public var castShadows: BooleanValue by castShadowsState

  /**
   * Color of the directional light.
   * Default value: "#ffffff".
   */
  public var color: ColorValue by colorState

  /**
   * Defines the transition of [color].
   * Default value: "#ffffff".
   */
  public var colorTransition: Transition by colorTransitionState

  /**
   * Overrides applying of color theme for [color] if "none" is set. To follow default theme "default"
   * should be set.
   * Default value: "default".
   */
  @MapboxExperimental
  public var colorUseTheme: StringValue by colorUseThemeState

  /**
   * Direction of the light source specified as [a azimuthal angle, p polar angle] where a indicates
   * the azimuthal angle of the light relative to north (in degrees and proceeding clockwise), and p
   * indicates polar angle of the light (from 0 degree, directly above, to 180 degree, directly below).
   * Default value: [210,30]. Minimum value: [0,0]. Maximum value: [360,90].
   */
  public var direction: DoubleListValue by directionState

  /**
   * Defines the transition of [direction].
   * Default value: [210,30]. Minimum value: [0,0]. Maximum value: [360,90].
   */
  public var directionTransition: Transition by directionTransitionState

  /**
   * A multiplier for the color of the directional light.
   * Default value: 0.5. Value range: [0, 1]
   */
  public var intensity: DoubleValue by intensityState

  /**
   * Defines the transition of [intensity].
   * Default value: 0.5. Value range: [0, 1]
   */
  public var intensityTransition: Transition by intensityTransitionState

  /**
   * Determines the shadow strength, affecting the shadow receiver surfaces final color. Values near 0.0 reduce the
   * shadow contribution to the final color. Values near to 1.0 make occluded surfaces receive almost no
   * directional light. Designed to be used mostly for transitioning between values 0 and 1.
   * Default value: 1. Value range: [0, 1]
   */
  public var shadowIntensity: DoubleValue by shadowIntensityState

  /**
   * Defines the transition of [shadowIntensity].
   * Default value: 1. Value range: [0, 1]
   */
  public var shadowIntensityTransition: Transition by shadowIntensityTransitionState

  @Composable
  private fun MapboxStyleManager.UpdateLightProperty(
    state: MutableState<out HoldsValue>,
    name: String
  ) {
    val value = state.value
    if (value.isNotInitial()) {
      logD(TAG, "update Directional light property: $id, $name, $value")
      setStyleLightProperty(id, name, value.value)
        .onError {
          logW(TAG, "update Directional light property error: $it")
        }
    }
  }

  @OptIn(MapboxExperimental::class)
  internal fun getProperties(): HashMap<String, Value> {
    return hashMapOf(
      "id" to Value(id),
      "type" to Value("directional"),
      "properties" to Value(
        hashMapOf<String, Value>().apply {
          if (castShadows.isNotInitial()) {
            this["cast-shadows"] = castShadows.value
          }
          if (color.isNotInitial()) {
            this["color"] = color.value
          }
          if (colorTransition.isNotInitial()) {
            this["color-transition"] = colorTransition.value
          }
          if (colorUseTheme.isNotInitial()) {
            this["color-use-theme"] = colorUseTheme.value
          }
          if (direction.isNotInitial()) {
            this["direction"] = direction.value
          }
          if (directionTransition.isNotInitial()) {
            this["direction-transition"] = directionTransition.value
          }
          if (intensity.isNotInitial()) {
            this["intensity"] = intensity.value
          }
          if (intensityTransition.isNotInitial()) {
            this["intensity-transition"] = intensityTransition.value
          }
          if (shadowIntensity.isNotInitial()) {
            this["shadow-intensity"] = shadowIntensity.value
          }
          if (shadowIntensityTransition.isNotInitial()) {
            this["shadow-intensity-transition"] = shadowIntensityTransition.value
          }
        }
      )
    )
  }

  @Composable
  internal fun UpdateProperties(mapboxMap: MapboxMap) {
    mapboxMap.UpdateLightProperty(castShadowsState, "cast-shadows")
    mapboxMap.UpdateLightProperty(colorState, "color")
    mapboxMap.UpdateLightProperty(colorTransitionState, "color-transition")
    mapboxMap.UpdateLightProperty(colorUseThemeState, "color-use-theme")
    mapboxMap.UpdateLightProperty(directionState, "direction")
    mapboxMap.UpdateLightProperty(directionTransitionState, "direction-transition")
    mapboxMap.UpdateLightProperty(intensityState, "intensity")
    mapboxMap.UpdateLightProperty(intensityTransitionState, "intensity-transition")
    mapboxMap.UpdateLightProperty(shadowIntensityState, "shadow-intensity")
    mapboxMap.UpdateLightProperty(shadowIntensityTransitionState, "shadow-intensity-transition")
  }

  /**
   * Overwrite the hashcode for [DirectionalLightState].
   */
  @OptIn(MapboxExperimental::class)
  override fun hashCode(): Int {
    return Objects.hash(
      castShadows,
      color,
      colorTransition,
      colorUseTheme,
      direction,
      directionTransition,
      intensity,
      intensityTransition,
      shadowIntensity,
      shadowIntensityTransition,
    )
  }

  /**
   * Overwrite the equals for [DirectionalLightState].
   */
  @OptIn(MapboxExperimental::class)
  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (javaClass != other?.javaClass) return false
    other as DirectionalLightState
    if (id != other.id) return false
    if (castShadows != other.castShadows) return false
    if (color != other.color) return false
    if (colorTransition != other.colorTransition) return false
    if (colorUseTheme != other.colorUseTheme) return false
    if (direction != other.direction) return false
    if (directionTransition != other.directionTransition) return false
    if (intensity != other.intensity) return false
    if (intensityTransition != other.intensityTransition) return false
    if (shadowIntensity != other.shadowIntensity) return false
    if (shadowIntensityTransition != other.shadowIntensityTransition) return false
    return true
  }

  /**
   * Overwrite the toString for [DirectionalLightState].
   */
  @OptIn(MapboxExperimental::class)
  override fun toString(): String {
    return "DirectionalLightState(castShadows=$castShadows, color=$color, colorTransition=$colorTransition, colorUseTheme=$colorUseTheme, direction=$direction, directionTransition=$directionTransition, intensity=$intensity, intensityTransition=$intensityTransition, shadowIntensity=$shadowIntensity, shadowIntensityTransition=$shadowIntensityTransition)"
  }

  /**
   * [DirectionalLightState] Holder class to be used within [Saver].
   *
   * @param savedProperties properties to be saved.
   */
  @Parcelize
  @TypeParceler<Value, ValueParceler>
  public data class Holder(
    val savedProperties: Map<String, Value>,
  ) : Parcelable

  /**
   * Public companion object.
   */
  public companion object {
    private const val TAG = "DirectionalLightState"

    /**
     * The default saver implementation for [DirectionalLightState].
     */
    public val Saver: Saver<DirectionalLightState, Holder> = Saver(
      save = { directionalLightState ->
        Holder(directionalLightState.getProperties()).also {
          logD(TAG, "save: $it")
        }
      },
      restore = { holder ->
        logD(TAG, "restore: $holder")
        val id: String = holder.savedProperties["id"]!!.contents as String
        @Suppress("UNCHECKED_CAST")
        val properties: Map<String, Value> = holder.savedProperties["properties"]!!.contents as HashMap<String, Value>
        DirectionalLightState(
          id = id,
          initialCastShadows = properties["cast-shadows"]?.let { BooleanValue(it) } ?: BooleanValue.INITIAL,
          initialColor = properties["color"]?.let { ColorValue(it) } ?: ColorValue.INITIAL,
          initialColorTransition = properties["color-transition"]?.let { Transition(it) } ?: Transition.INITIAL,
          initialColorUseTheme = properties["color-use-theme"]?.let { StringValue(it) } ?: StringValue.INITIAL,
          initialDirection = properties["direction"]?.let { DoubleListValue(it) } ?: DoubleListValue.INITIAL,
          initialDirectionTransition = properties["direction-transition"]?.let { Transition(it) } ?: Transition.INITIAL,
          initialIntensity = properties["intensity"]?.let { DoubleValue(it) } ?: DoubleValue.INITIAL,
          initialIntensityTransition = properties["intensity-transition"]?.let { Transition(it) } ?: Transition.INITIAL,
          initialShadowIntensity = properties["shadow-intensity"]?.let { DoubleValue(it) } ?: DoubleValue.INITIAL,
          initialShadowIntensityTransition = properties["shadow-intensity-transition"]?.let { Transition(it) } ?: Transition.INITIAL,
        )
      }
    )
  }
}
// End of generated file.