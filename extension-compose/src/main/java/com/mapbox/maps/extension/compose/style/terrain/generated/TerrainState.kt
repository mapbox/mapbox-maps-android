// This file is generated.

package com.mapbox.maps.extension.compose.style.terrain.generated

import android.os.Parcelable
import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.Stable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.saveable.Saver
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import com.mapbox.bindgen.Value
import com.mapbox.maps.extension.compose.style.DoubleValue
import com.mapbox.maps.extension.compose.style.Transition
import com.mapbox.maps.extension.compose.style.internal.ValueParceler
import com.mapbox.maps.extension.compose.style.sources.SourceState
import com.mapbox.maps.extension.compose.style.sources.generated.RasterDemSourceState
import com.mapbox.maps.extension.compose.style.terrain.TerrainStateApplier
import kotlinx.parcelize.Parcelize
import kotlinx.parcelize.TypeParceler
import java.util.Objects

/**
 * Create and [rememberSaveable] a [TerrainState] using [TerrainState.Saver].
 * [init] will be called when the [TerrainState] is first created to configure its
 * initial state.
 *
 * @param rasterDemSourceState Mandatory [RasterDemSourceState] to which terrain will be added.
 * @param key An optional key to be used as a key for the saved value. If not provided we use the
 * automatically generated by the Compose runtime which is unique for the every exact code location
 * in the composition tree.
 * @param init A function initialise this [TerrainState].
 */
@Composable
public inline fun rememberTerrainState(
  rasterDemSourceState: RasterDemSourceState,
  key: String? = null,
  crossinline init: TerrainState.() -> Unit = {}
): TerrainState = rememberSaveable(key = key, saver = TerrainState.Saver) {
  TerrainState(rasterDemSourceState).apply(init)
}

/**
 * A global modifier that elevates layers and markers based on a DEM data source.
 *
 * @see [The online documentation](https://docs.mapbox.com/mapbox-gl-js/style-spec/terrain/)
 */
@Stable
public class TerrainState private constructor(
  internal val applier: TerrainStateApplier,
  exaggeration: DoubleValue,
  exaggerationTransition: Transition,
) {

  public constructor(
    /**
     * The [RasterDemSourceState] that drives the terrain.
     */
    rasterDemSourceState: RasterDemSourceState,
  ) : this(
    TerrainStateApplier(
      rasterDemSourceState = rasterDemSourceState,
      initialProperties = emptyMap(),
      initial = false
    ),
    DoubleValue.INITIAL,
    Transition.INITIAL,
  )

  /**
   * Constructor used by [INITIAL] and [DISABLED].
   */
  private constructor(initial: Boolean) : this(
    TerrainStateApplier(
      rasterDemSourceState = null,
      initialProperties = emptyMap(),
      initial = initial
    ),
    DoubleValue.INITIAL,
    Transition.INITIAL,
  )

  private val exaggerationState: MutableState<DoubleValue> = mutableStateOf(exaggeration)

  /**
   * Exaggerates the elevation of the terrain by multiplying the data from the DEM with this value.
   * Default value: 1. Value range: [0, 1000]
   */
  public var exaggeration: DoubleValue by exaggerationState

  @Composable
  private fun UpdateExaggeration() {
    exaggerationState.value.apply {
      if (notInitial) {
        applier.setProperty("exaggeration", value)
      }
    }
  }
  private val exaggerationTransitionState: MutableState<Transition> = mutableStateOf(exaggerationTransition)

  /**
   * Defines the transition of [exaggeration].
   * Default value: 1. Value range: [0, 1000]
   */
  public var exaggerationTransition: Transition by exaggerationTransitionState

  @Composable
  private fun UpdateExaggerationTransition() {
    exaggerationTransitionState.value.apply {
      if (notInitial) {
        applier.setProperty("exaggeration-transition", value)
      }
    }
  }

  @Composable
  internal fun UpdateProperties() {
    applier.rasterDemSourceState?.UpdateProperties()
    UpdateExaggeration()
    UpdateExaggerationTransition()
  }

  private fun getProperties(): Map<String, Value> =
    listOfNotNull(
      ("exaggeration" to exaggeration.value).takeIf { exaggeration.notInitial },
      ("exaggeration-transition" to exaggerationTransition.value).takeIf { exaggerationTransition.notInitial },
    ).toMap()

  /**
   * See [Any.equals]
   */
  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (javaClass != other?.javaClass) return false

    other as TerrainState

    if (applier != other.applier) return false
    if (exaggeration != other.exaggeration) return false
    if (exaggerationTransition != other.exaggerationTransition) return false

    return true
  }

  /**
   * See [Any.hashCode]
   */
  override fun hashCode(): Int = Objects.hash(
    applier,
    exaggeration,
    exaggerationTransition,
  )

  /**
   * @return a string representation of the object.
   */
  override fun toString(): String {
    return "TerrainState(applier=$applier, exaggeration=$exaggeration, exaggerationTransition=$exaggerationTransition)"
  }

  /**
   * Terrain Holder class to be used within [Saver].
   */
  @Parcelize
  @TypeParceler<Value, ValueParceler>
  public data class Holder internal constructor(
    /**
     * Saved holder for [RasterDemSourceState].
     */
    val rasterDemSourceStateHolder: SourceState.Holder?,
    /**
     * Saved properties.
     */
    val savedProperties: Map<String, Value>,
    /**
     * If it is initial value meaning that no runtime terrain was set.
     */
    val initial: Boolean,
  ) : Parcelable

  /**
   * Public companion object.
   */
  public companion object {
    /**
     * The default saver implementation for [TerrainState]
     */
    public val Saver: Saver<TerrainState, Holder> = Saver(
      save = { it.applier.save(it.getProperties()) },
      restore = { holder ->
        TerrainState(
          TerrainStateApplier(
            holder.rasterDemSourceStateHolder?.let {
              RasterDemSourceState.Saver.restore(it)
            },
            holder.savedProperties,
            holder.initial
          ),
          exaggeration = holder.savedProperties["exaggeration"]?.let { DoubleValue(it) } ?: DoubleValue.INITIAL,
          exaggerationTransition = holder.savedProperties["exaggeration-transition"]?.let { Transition(it) } ?: Transition.INITIAL,
        )
      }
    )

    /**
     * Initial value for [TerrainState], meaning that no changes will be applied to the current style.
     */
    @JvmField
    internal val INITIAL: TerrainState = TerrainState(initial = true)

    /**
     * Disabled value for [TerrainState], setting disabled will result in removing terrain.
     */
    @JvmField
    public val DISABLED: TerrainState = TerrainState(initial = false)
  }
}
// End of generated file.